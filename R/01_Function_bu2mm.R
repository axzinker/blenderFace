#' Scale blender data
#' 
#' Scales columns of a data frame according to a scale factor. For example, the
#' scale factor can be the diameter of a glue dot measured in blender. The
#' columns are rescaled accordingly to represent Millimeter instead of blender
#' units as measurement unit.
#' 
#' @param data Data frame containig the columns which should be rescaled.
#'   Remaining colums will be returned untouched. The data frame should contain 
#'   many subjects, e.g. as generated by the function ConcatData().
#' @param colNames Character vector with names of the columns of the data 
#'   data-frame which should be rescaled.
#' @param colNameSubj Character vector with a single value containig the name 
#'   of the subject column of the data data-frame.
#' @param scaleFactor Numeric vector containing the values of the real world
#'   object measured in blender for each subject in the data data-frame. For 
#'   example, this can be the diameter of a glue dot measured in blender. 
#'   The scaleFactor vector must contain a scale value for each subject in the 
#'   data data-frame. The sorting of subjects in data data-frame and 
#'   scaleFactor vector must be the same.
#' @param rwMeasure Optional. Real world measure of the object diameter used to
#'   rescale the blender data. The default is the diameter of a glue dot of 
#'   8 millimeter.
#' @param verbose If TRUE, the function prints verbose output. Otherwise not.
#'   
#' @return Rescaled input data frame.
#'   
#' @author Axel Zinkernagel \email{zinkernagel@uni-landau.de}
#'   
#' @examples
#' \dontrun{scaleBlenderData()}
#' 
#' @export

fcat = function(...,newline=TRUE) {if (newline) cat(...,"\n") else cat(...); flush.console() }  # immediate console output

bu2mm <- function(data, colNames, colNameSubj, scaleFactor, rwMeasure = 8, verbose = FALSE) {
    # Error handling
    if (!(is.data.frame(data))) {
        stop("Argument data does not contain a data frame!")
    }

    if (!(is.character(colNames))) {
        stop("Argument colNames is missing or not of type character!")
    }

    if (!(is.character(colNameSubj))) {
        stop("Argument colNameSubj is missing or not of type character!")
    }

    if (any(is.na(match(colNames,colnames(data))))) {
       stop(paste("Invalid column(s): ",colNames[which(is.na(match(colNames,colnames(data))))]))
    }

    if (is.character(scaleFactor))   # is it a valid column in the data set?
       stopifnot(scaleFactor %in% colnames(data))
    else                             # test, if data frame subjects and scaleFactor subjects have the same length
    if (!(is.numeric(scaleFactor)) | !(length(scaleFactor) > 2))
        stop("Argument scaleFactor is neither a column name nort of type numeric or contains only one value!")
    else
    if (length(unique(data[[colNameSubj]])) != length(scaleFactor))
        stop(paste("Number of subjects in data data-frame (", length(unique(data[[colNameSubj]])), ") is not equal to length of scaleFactor (", 
            length(scaleFactor), ")!", sep = ""))


    if (!(is.numeric(rwMeasure)) | (length(rwMeasure) != 1)) {
        stop("Argument rwMeasure is not of type numeric or contains more than one value!")
    }

    if (!(is.logical(verbose))) {
        stop("Argument verbose is not of type logical!")
    }
    
    # Principle of rescaling: Perform scaling via rule of proportion (BU = blender units).
    # Example: Assuming the glue dot has 8 mm diameter and we observe a coordinate of x=50 bu, then:
    # 1. (glue dot in BU / 8mm) = BU per mm  [bu/mm]
    # 2. (variable in BU / x mm)
    #       BU per mm        =
    # x = (variable in BU * 8 mm) / glue dot in BU
    # ---> the factor to scale with is 8mm / glue dot in BU -> rwMeasure/scaleFactor[i]


    if (is.character(scaleFactor))
       data[,colNames] = data[,colNames] * rwMeasure/data[,scaleFactor]
    else {
          subjects <- unique(data[[colNameSubj]])   # Determine number of subjects in data
          for (i in 1:length(subjects)) {           # *** RA: tapply?
             if (verbose) fcat(paste("Perform scaling to real wold measures for subject ", i, " of ", length(subjects), ".", sep = ""))
             isF <- rwMeasure/scaleFactor[i]        # Determine individual scaleFactor    *** RA (*)
             data[data$subject == subjects[i], colNames] <- data[data$subject == subjects[i], colNames] * isF  # Rescale data per subject
          }  # end for
          }  # end else

    # (*) Dieser Ansatz setzt voraus, dass der sf-Vektor die gleiche Sortierung hat wie der Datensatz!
    
    invisible(data)
}
