#' Scale blender data
#' 
#' Scales columns of a data frame according to a scale factor. For example, the
#' scale factor can be the diameter of a glue dot measured in blender. The
#' columns are rescaled accordingly to represent Millimeter instead of blender
#' units as measurement unit.
#' 
#' @param data Data frame containig the columns which should be rescaled.
#'   Remaining colums will be returned untouched. The data frame should contain 
#'   many subjects, e.g. as generated by the function ConcatData().
#' @param colNames Character vector with names of the columns of the data 
#'   data-frame which should be rescaled.
#' @param colNameSubj Character vector with a single value containig the name 
#'   of the subject column of the data data-frame.
#' @param scaleFactor Numeric vector containing the values of the real world
#'   object measured in blender for each subject in the data data-frame. For 
#'   example, this can be the diameter of a glue dot measured in blender. 
#'   The scaleFactor vector must contain a scale value for each subject in the 
#'   data data-frame. The sorting of subjects in data data-frame and 
#'   scaleFactor vector must be the same.
#' @param rwMeasure Optional. Real world measure of the object diameter used to
#'   rescale the blender data. The default is the diameter of a glue dot of 
#'   8 millimeter.
#' @param verbose If TRUE, the function prints verbose output. Otherwise not.
#'   
#' @return Rescaled input data frame.
#'   
#' @author Axel Zinkernagel \email{zinkernagel@uni-landau.de}
#'   
#' @examples
#' \dontrun{scaleBlenderData()}
#' 
#' @export
scaleBlenderData <- function(data, colNames, colNameSubj, scaleFactor, rwMeasure = 8, verbose = FALSE) {
    # Error handling
    if (!(is.data.frame(data))) {
        stop("Argument data does not contain a data frame!")
    }
    if (!(is.character(colNames))) {
        stop("Argument colNames is missing or not of type character!")
    }
    if (!(is.character(colNameSubj))) {
        stop("Argument colNameSubj is missing or not of type character!")
    }
    if (!(is.numeric(scaleFactor)) | !(length(scaleFactor) > 2)) {
        stop("Argument scaleFactor is not of type numeric or contains only one value!")
    }
    # test, if data frame subjects and scaleFactor subjects have the same length
    if (length(unique(data[[colNameSubj]])) != length(scaleFactor)) {
        stop(paste("Number of subjects in data data-frame (", length(unique(data[[colNameSubj]])), ") is not equal to length of scaleFactor (", 
            length(scaleFactor), ")!", sep = ""))
    }
    if (!(is.numeric(rwMeasure)) | (length(rwMeasure) != 1)) {
        stop("Argument rwMeasure is not of type numeric or contains more than one value!")
    }
    if (!(is.logical(verbose))) {
        stop("Argument verbose is not of type logical!")
    }
    
    # Principle of rescaling: Perform scaling via rule of proportion.  Example: Assuming the glue dot has 8 mm diameter (BU = blender
    # units): (glue dot in BU / 8mm) = (variable in BU / x mm) x = (variable in BU * 8 mm) / glue dot in BU -> the factor to scale with
    # is 8mm / glue dot in BU -> rwMeasure/scaleFactor[i]
    
    # Determing number of subjects in data
    subjects <- unique(data[[colNameSubj]])
    
    for (i in 1:length(subjects)) {
        if (verbose) {
            writeLines(paste("Perform scaling to real wold measures for subject ", i, " of ", length(subjects), ".", sep = ""))
        }
        # Determine individual scaleFactor
        sF <- rwMeasure/scaleFactor[i]
        # Rescale data per subject
        data[data$subject == subjects[i], colNames] <- data[data$subject == subjects[i], colNames] * sF
    }
    
    return(data)
}
