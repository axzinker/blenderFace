---
title: "blenderFace"
author: "Axel Zinkernagel"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{blenderFace}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Workflow of Blender-data post-processing with the blenderFace package 

For using the blenderFace package it is assumed, that you have tracked facial movements for at least two subjects, following the "Step_by_Step_Instructions.pdf". The output of this procedure is a csv file for each participant, which includes the x,y,z-axis movement of the tracked facial markers. Additionally, you need to mark the frames for which a stimulus was presented to the participants. This must be done for each participant (a.k.a. csv file) in a column called "Stimulustype" which marks the frames for which a stimulus was presented to the participant (e.g., "posing happiness" or viewing an emotion eliciting film clip). Unfortunately, there is no function or procedure that helps you with this step, because it strongly depends on how you presented the stimuli and how you recorded the video clips of the participants. If you know the start- and stop-frames of the presented stimuli, for example, by recording the computer screen via a mirror in the back of the participant, you can fill in  the stimulustype-colums by hand using a spreadsheet programm. 

The blenderFace package contains raw data sets of two subjects (in fact, it is one subject recorded and tracked twice) which already have the stimulustype-column attached. 

First, be sure to have installed and loaded the package:
```{r, eval=FALSE}
install.packages("devtools")
library(devtools)
install_github("axzinker/blenderFace", built_vignettes = TRUE)
library(blenderFace)
```

```{r,echo=FALSE}
library(blenderFace)
```

@Axel: fix me: Übersicht über generellen Ablauf der Funktionen, Aufzählung


## Concatenating raw data files to one large RData file with the function *concatBlenderFiles*

To perform the concatenation of files, use the *concatBlenderFiles* function of the package. If you have followed the "Step-by-Step"-instructions, the subject number is part of the file name. However, the file name ends with "_Step_03" for each participant. Please rename the files, so that the subject number is the last number before the filetype ending (e.g., ".csv"). For example, if you have the file "Subject_39_Step_03.csv", rename it into "Subject_39.csv". The package includes two sample csv files in the `./inst/extdata` directory ("Subject_01.csv","Subject_02.csv"). Although the *concatBlenderFiles* function does some basic input checks, be aware that this function writes on your hard disk and may change/overwrite/delete files, if messed up input strings are given!

The path specifications are adapted for the package example. Please change the paths to your needs.

```{r,eval=FALSE}
inputdir <- paste(system.file(package = "blenderFace"),"/extdata/",sep="")
outputdir <- paste(system.file(package = "blenderFace"),"/data/",sep="")
filenames <- c("Subject_01.csv","Subject_02.csv")

# If all files in a directory should be processes, use:
# filenames <- list.files(inputdir, pattern = paste("[0-9]",".csv","$",sep=""))

concatBlenderFiles(dataFileNames = filenames, inputDirectory = inputdir, subjectColumn = FALSE, outputFilename = "rawdata.rda", outputDirectory = outputdir, verbose = TRUE)
```

The console output of the *concatBlenderFiles* function shows:

```{r,eval=FALSE}
Step 1: Determing unique column names and number of rows of the files to be concatenated.
Reading 2 files:
Reading file Subject_01.csv (1/2)
  Adding 1714 rows to data frame of actually 0 rows.
Reading file Subject_02.csv (2/2)
  Adding 1692 rows to data frame of actually 1714 rows.

The final data frame will have 51 columns and 3406 rows.

These are the unique column names of all files to be concatenated. Check, if they are correct.
 [1] "AU_01_L_x"    "AU_01_L_y"    "AU_01_L_z"    "AU_01_R_x"    "AU_01_R_y"    "AU_01_R_z"    "AU_02_L_x"    "AU_02_L_y"    "AU_02_L_z"   
[10] "AU_02_R_x"    "AU_02_R_y"    "AU_02_R_z"    "AU_06_L_x"    "AU_06_L_y"    "AU_06_L_z"    "AU_06_R_x"    "AU_06_R_y"    "AU_06_R_z"   
[19] "AU_08_x"      "AU_08_y"      "AU_08_z"      "AU_09_L_x"    "AU_09_L_y"    "AU_09_L_z"    "AU_09_R_x"    "AU_09_R_y"    "AU_09_R_z"   
[28] "AU_10_L_x"    "AU_10_L_y"    "AU_10_L_z"    "AU_10_R_x"    "AU_10_R_y"    "AU_10_R_z"    "AU_11_L_x"    "AU_11_L_y"    "AU_11_L_z"   
[37] "AU_11_R_x"    "AU_11_R_y"    "AU_11_R_z"    "AU_12_L_x"    "AU_12_L_y"    "AU_12_L_z"    "AU_12_R_x"    "AU_12_R_y"    "AU_12_R_z"   
[46] "AU_16_x"      "AU_16_y"      "AU_16_z"      "Frame"        "Stimulustype"
Abort Script? (Press 'y' to abort, or any other key to coninue)
? 
Step 2: Concatenating files.

Preallocating data frame of a 51x3406 matrix.
Concatenating file Subject_01.csv (1/2)
Concatenating file Subject_02.csv (2/2)
Step 3: Saving output file (it takes time to save large files).

```

As main output of this function a file with the filename given in `outputFilename` is saved in the directory given in as `outputDirectory`. The data frame stored in this file contains the data of all concatenated subjects. This output file of the two sample subjects is also attached to this package and labeled `rawdata`.

Finally, check if the names for the "Stimulustype" column are euqal for all cases, e.g., they do not contain misspellings. If not, perform the corrections in the corresponding csv files of the participants.

```{r}
table(rawdata$Stimulustype, rawdata$subject)
```

## Scale Blender units to millimeter by using the function *bu2mm*

The next step in Blender data post-processing is to scale the Blender units (BU) into mm. In principle, the rescaling is done by the rule of proportion:
$$
\begin{equation*}
  \frac{\mbox{Diameter in Blender units}}{\mbox{Diameter in millimeter}} =
  \mbox{Factor to divide BU by, to obtain mm}
\end{equation*}
$$

For example, a glue dot has a diameter of 8 mm and is measured in Blender with a diameter of 1 BU:

$$
\begin{equation*}
  \frac{1 \mbox{ BU}}{8 \mbox{ mm}} = 0.125 \\
  \frac{2 \mbox{ BU}}{0.125} = 16 \mbox{ mm}
\end{equation*}
$$

In the sample videos "Subject_01.mp4" and "Subject_02.mp4" glue-dots with 8 mm diameter were used. To perform the rescaling for the `rawdata` dataset, the glue-dot diameter measurements in BU for each participant are needed. If you have followed the "Step-by-Step"-instructions, you have measured and saved the glue-dot diameters in BU in a file called "Blender_Scalingdata.csv". For the two example subjects, the file "Blender_Scalingdata.csv" is included in the package and should be loaded to get the scaling parameters. Please note, that the paths used in the example below are specified for the package datasets. Therefore, adapt the paths matching your work environment accordingly.

```{r}
# Load the file "Blender_Scalingdata.csv"
scaledata <- read.csv(system.file("extdata", "Blender_Scalingdata.csv", package = "blenderFace"), header = TRUE, sep =",")
# Be sure to have the data sorted by subjects
scaledata <- scaledata[with(scaledata, order(scaledata$subject)), ]

# Load the file "rawdata"
data(rawdata, package="blenderFace") # for the package example, please comment out
# load("path/to/your/directory/rawdata.rda") # uncomment and adapt to your work environment
# Be sure to have the data sorted by subjects
rawdata <- rawdata[with(rawdata, order(rawdata$subject)), ]
```

From the loaded data files the relevant information for the *bu2mm* function has to be extracted:

```{r,eval=TRUE}
# Geting the column names of the scaledata dataframe
names(scaledata)

# Determin the dataframe columns which should be scaled:
names(rawdata)
# -> Frame, Stimulustype and subject should not be scaled -> removed for variable colNames
colNames <- c("AU_01_L_x", "AU_01_L_y", "AU_01_L_z", "AU_01_R_x", "AU_01_R_y", "AU_01_R_z", "AU_02_L_x", "AU_02_L_y", "AU_02_L_z", "AU_02_R_x", "AU_02_R_y", 
              "AU_02_R_z", "AU_06_L_x", "AU_06_L_y", "AU_06_L_z", "AU_06_R_x", "AU_06_R_y", "AU_06_R_z", "AU_08_x", "AU_08_y", "AU_08_z", "AU_09_L_x",  
              "AU_09_L_y", "AU_09_L_z", "AU_09_R_x", "AU_09_R_y", "AU_09_R_z", "AU_10_L_x", "AU_10_L_y", "AU_10_L_z", "AU_10_R_x", "AU_10_R_y", "AU_10_R_z",  
              "AU_12_L_x", "AU_12_L_y", "AU_12_L_z", "AU_12_R_x", "AU_12_R_y", "AU_12_R_z", "AU_16_x", "AU_16_y", "AU_16_z")

# To not overwrite data, use a new data frame (dataSmm means data scaled in millimeter)
dataSmm <- bu2mm(data = rawdata, colNames = colNames, colNameSubj = "subject", scaleFactor = scaledata$GlueDotDiameter, rwMeasure = 8, verbose = TRUE)

# Optionally save data at this stage of analysis
# save(dataSmm, file = "path/to/your/directory/dataSmm.rda")
```
<!-- this is necessary to save the data file in /data but not needed in the vignette
```{r, eval=TRUE}
devtools::use_data(dataSmm, overwrite = TRUE)
```
-->


In the output data frame of this function is rescaled, and therefore movements can be interpreted in millimeter.

## Scale facial movements to a standardized face by using the function *face2stdFace*

Sometimes it is useful not to interpret the movements in an absolute measure, such as millimeter, but to be able to compare movements of different face sizes. Imagine, you want to compare the facial expression of a child sample with the facial expression of an adult sample. Because the head sizes of the children are smaller, the facial movements are also smaller, compared to the adult sample. Therefore, the standardization of different face sizes to a standardized face is needed. The function *face2stdFace* performs this step for you. The proportions of the standard face used here are based on biological and artistic resources (*@Rainer: fix me: Literaturangaben?*). In the standardized face the length and the height of the head have each a value of 1, while the left-pupil -- right-pupil distance and the left-pupil -- left-mouth-corner distance are scaled to 1/3rd of the face height and face width.

As individual measures for face width and face height, the individual left-pupil -- right-pupil, and the left-pupil -- left-mouth-corner distances are used. If you have followed the "Step-by-Step"-instructions, you have measured and saved the these distances in BU in a file called "Blender_Scalingdata.csv". To have comparable measures for all subjects, the left-pupil -- right-pupil distance and the left-pupil -- left-mouth-corner distance are set in proportion to 1/3rd to achieve a factor by which the x-axis and the y-axis must be divided, to obtain a standardized scaling. Additionally, if the left-mouth-corner -- right-mouth-corner distance or the right-pupil -- right-mouth-corner distance are given, the *face2stdFace* function allows to compute a mean of these distances for the x-, and the y-axis to have a more reliable distance measure. However, to our experience, the mouth corner distance ist not such an reliable measure as the pupil distance is.

Standardizing the z-axis is not (yet) implemented, mainly due to the lack of an appropriate facial distance measure for scaling the z-axis. As a consequence, at the monment it is not meaningful to rescale the z-axis. Therefore the z-axis is omitted in further analyses.

Again, as in function *bu2mm* the rescaling is done via the rule of proportion. For subject 1 in the example data in the file "Blender_Scalingdata.csv", the left-pupil -- right-pupil distance is measured with 0.3346 BU in Blender. This distance is set in proportion to 1/3 to obtain a scaling factor for the x-axis.
$$
\begin{equation*}
  \frac{0.3346\mbox{ BU}}{0.\bar{3}} = 1.0038
\end{equation*}
$$
as scale factor for the x-axis. The left-pupil -- left-mouth-corner distance for subject 1 is measured with 0.36611 BU. Therefore, the scale factor for the y-axis is
$$
\begin{equation*}
  \frac{0.36611\mbox{ BU}}{0.\bar{3}} = 1.09833
\end{equation*}
$$

If not yet loaded, load the files `scaledata` and `rawdata`  into Rs environment:
```{r}
# Load the file "Blender_Scalingdata.csv"
scaledata <- read.csv(system.file("extdata", "Blender_Scalingdata.csv", package = "blenderFace"), header = TRUE, sep =",")
# Be sure to have the data sorted by subjects
scaledata <- scaledata[with(scaledata, order(scaledata$subject)), ]

# Load the file "rawdata"
data(rawdata, package="blenderFace") # for the package example, please comment out
# load("path/to/your/directory/rawdata.rda") # uncomment and adapt to your work environment
# Be sure to have the data sorted by subjects
rawdata <- rawdata[with(rawdata, order(rawdata$subject)), ]
```

Subsequently, prepare the parameters and call the function *face2stdFace*:
```{r}
# Geting the column names of the scaledata dataframe
names(scaledata)

# Determin the dataframe columns which should be scaled:
names(rawdata)

# -> Frame, Stimulustype, subject and z-axis values should not be scaled -> removed for variable colNames
colNames <- c("AU_01_L_x", "AU_01_L_y", "AU_01_R_x", "AU_01_R_y", "AU_02_L_x", "AU_02_L_y", "AU_02_R_x", "AU_02_R_y", 
              "AU_06_L_x", "AU_06_L_y", "AU_06_R_x", "AU_06_R_y", "AU_08_x", "AU_08_y", 
              "AU_09_L_x", "AU_09_L_y", "AU_09_R_x", "AU_09_R_y", "AU_10_L_x", "AU_10_L_y", "AU_10_R_x", "AU_10_R_y",  
              "AU_12_L_x", "AU_12_L_y", "AU_12_R_x", "AU_12_R_y", "AU_16_x", "AU_16_y")

# To not overwrite data, use a new data frame (dataStdF means data of standaradized faces)
dataStdF <- face2stdFace(data = rawdata, colNames = colNames, colNameSubj = "subject", pupilDist = scaledata$PupilPupilDistance, leftPMDist = scaledata$LeftPupilLeftMouthcornerDistance)

# Optionally save data at this stage of analysis
# save(dataStdF, file = "path/to/your/directory/dataStdF.rda")
```
<!-- this is necessary to save the data file in /data but not needed in the vignette
```{r, eval=TRUE}
devtools::use_data(dataStdF, overwrite = TRUE)
```
-->
Be aware, that if you want to standardize data with the *face2stdFace* function you have previously rescaled to millimeter with the *bu2mm* funktion, you also have to rescale the left-pupil -- right-pupil and the left-pupil -- left-mouth-corner distance into millimeter, to achieve a correct scaling!

```{r}
# First, compute the scale factor to scale into millimenter
mm_scaleFactor <- scaledata$GlueDotDiameter / 8

# Then divide distances by that scalefactor
dataStdFmm <- face2stdFace(data = dataSmm, colNames = colNames, colNameSubj = "subject", pupilDist = (scaledata$PupilPupilDistance/mm_scaleFactor), leftPMDist = (scaledata$LeftPupilLeftMouthcornerDistance / mm_scaleFactor))

# Axel: fix me: this should be identical, however, it is not completely identical:
cor.test(dataStdF$AU_01_L_x,dataStdFmm$AU_01_L_x)
cor.test(dataStdF$AU_01_L_y,dataStdFmm$AU_01_L_y)
# ...

```

## Center the movement of the markers with the function *centerCond*

The function *centerCond* sets the first frame of a stimulus episode (e.g., the “posing happiness” episode in the "stimulustype" column of the example data frames) to x/y/z = 0 and substracts the offset of the first frame from all remainig frames of this stimulus episode. This is needed, since the absolute positions of the markers on the participant`s face are not equal for all participants, because the faces differ in their shape and size, and the markers were drawn relatively arbitrary and unaccurate on the participants face^[Otherwise a very standardized and accurate procedure of drawing the markers would have been necessary.].

Therefore, at the start frame of a stimulus episode the movement of a marker starts at x=0, y=0 and z=0 and moves from there on. The advantage is, that you can easily aggregate facial movements over participants, or compare marker movements of participants for different stimulus episodes.

Because the processing of this marker centering is computationally very intensive, this function uses parallelizing and computes on n-1 cores of the computer it runs on. Use the `verbose` option to visualize the progress of this function.

```{r}
colNames <- c("AU_01_L_x", "AU_01_L_y", "AU_01_R_x", "AU_01_R_y", "AU_02_L_x", "AU_02_L_y", "AU_02_R_x", "AU_02_R_y", 
              "AU_06_L_x", "AU_06_L_y", "AU_06_R_x", "AU_06_R_y", "AU_08_x", "AU_08_y", 
              "AU_09_L_x", "AU_09_L_y", "AU_09_R_x", "AU_09_R_y", "AU_10_L_x", "AU_10_L_y", "AU_10_R_x", "AU_10_R_y",  
              "AU_12_L_x", "AU_12_L_y", "AU_12_R_x", "AU_12_R_y", "AU_16_x", "AU_16_y")

#dataCen <- centerCond(dataStdF, colNames = colNames, colNameSubj = "subject", colNameFrames = "Frame", colNameCond = "Stimulustype", verbose = TRUE)
```

Axel: fix me from here: Funktion scheint nicht mehr zu laufen (innerhalb der parallelized loop)

## Plotting control plots

Graphical plots are a good way to check data and rescaled data for outliers, artefacts and plausibility. The blenderFace package provides several functions to visualize the data.

### Plot the x- and y-axis movement per marker over the frames with the function *plotXYmmpf*

This function produces a raw data plot. It plots the x-, and y-axis movement of a marker per frame for a single participant. The plot may be used to find artefacts recording problems (e.g., scratching the facial skin and therefore moving markers).

The x-axis presents the frames and the y-axis the marker movement. In the example below AU_09 of subject 2 is used.

```{r, fig.show='hold'}
# Selecting data for subject 2
# Additionally, omit untracked frames at the start and the end of the video clip
data_Subj2 <- subset(dataSmm, subset = ((dataSmm$subject == 2) & (dataSmm$Frame >= 690)& (dataSmm$Frame <= 1610)))
plotXYmmpf(frames = data_Subj2$Frame, xMarker = data_Subj2$AU_09_L_x, yMarker = data_Subj2$AU_09_L_y, center = FALSE, title = "Subject 1, AU_09_L")
# Plot the right marker with stimulus episodes
plotXYmmpf(frames = data_Subj2$Frame, xMarker = data_Subj2$AU_09_R_x, yMarker = data_Subj2$AU_09_R_y, stimF = data_Subj2$Stimulustype, center = FALSE, title = "Subject 1, AU_09_R",color = c("blue","green"))
```

To better compare left and right movements (e.g., for judging symmetry of the facial expression), combine the two plots. To achieve an appropriate scaling, use the `center` switch. Note, that for the left and the right marker the movement on the x-axis aims into the opposite direction.

```{r, fig.show='hold'}
# Plotting left marker of AU_09 (Centered)
plotXYmmpf(frames = data_Subj2$Frame, xMarker = data_Subj2$AU_09_L_x, yMarker = data_Subj2$AU_09_L_y, center = TRUE, title = "Subject 1, AU_09")
# Adding right marker of AU09
plotXYmmpf(frames = data_Subj2$Frame, xMarker = data_Subj2$AU_09_R_x, yMarker = data_Subj2$AU_09_R_y, center = TRUE, color = c("blue",
  "green"), overplot = TRUE)
```

### Plot the movement of the markers on a standardized head with the function *plotXhead*

This function plots the raw data of several facial markers on a standardized head model. It is possible to plot a single subject or aggregated subjects. To get meaninful and well scaled plots use the function *face2stdFace* first. To have the position of the markers at the defined starting positions be sure to have used the functon *centerCond* first.

```{r, fig.show='hold'}
colNames <- c("AU_01_L_x", "AU_01_L_y", "AU_01_R_x", "AU_01_R_y", "AU_02_L_x", "AU_02_L_y", "AU_02_R_x", "AU_02_R_y", 
              "AU_06_L_x", "AU_06_L_y", "AU_06_R_x", "AU_06_R_y", "AU_08_x", "AU_08_y", 
              "AU_09_L_x", "AU_09_L_y", "AU_09_R_x", "AU_09_R_y", "AU_10_L_x", "AU_10_L_y", "AU_10_R_x", "AU_10_R_y",  
              "AU_12_L_x", "AU_12_L_y", "AU_12_R_x", "AU_12_R_y", "AU_16_x", "AU_16_y")

# Select data for plotting (selecting stimulus type and omit z-axis)
data_Subj_happy <- subset(dataStdF, subset = (dataStdF$Stimulustype == "posed_happy"), select = colNames)
data_Subj_disgust <- subset(dataStdF, subset = (dataStdF$Stimulustype == "posed_disgust"), select = colNames)

# Define the positions for the markers for the standardized face of x (-1,1) and y (-1,1) size as named list
dataPos <- list(AU_01_L = c(-.3,.7), AU_01_R = c(.3,.7), AU_02_L = c(-.7,.7), AU_02_R = c(.7,.7), 
            AU_06_L = c(-.5,.2), AU_06_R = c(.5,.2), AU_08 = c(0,-.6), 
            AU_09_L = c(-.2,.2), AU_09_R = c(.2,.2), AU_10_L = c(-.2,-.6), AU_10_R = c(.2,-.6), 
            AU_12_L = c(-.3,-.7), AU_12_R = c(.3,-.7), AU_16 = c(0,-.8)) 


plotXhead(data = data_Subj_happy, dataPos = dataPos, title = "All Subjects, neutral")
# For debugging purposes the marker start positions are plotted
plotXhead(data = data_Subj_disgust, dataPos = dataPos, title = "All Subjects, disgust", plotDataPos = TRUE)
```

This function can also be used to compare facial movements
```{r, fig.show='hold'}
plotXhead(data = data_Subj_happy, dataPos = dataPos, title = "All Subjects, neutral vs. disgust")
plotXhead(data = data_Subj_disgust, dataPos = dataPos, overplot = TRUE, color = "red")
```

### Plot aggregated marker movement per stimulus condition using the function *plotMmpCond*

The function plots aggregated data of one or more subjects per marker per condition. This plot facilitates the comparison of the movement of a marker per stimulus type. The median and the quartiles are plottet in different colors for each stimulus type.

```{r, fig.show='hold'}
plotMmpCond(data = dataStdF, colNames = c("AU_09_L_x", "AU_09_L_y"), colNameCond = "Stimulustype", title = "AU_09_L",xlim = c(-.2,.2), ylim = c(-.2,.2))
plotMmpCond(data = dataStdF, colNames = c("AU_09_R_x", "AU_09_R_y"), colNameCond = "Stimulustype", title = "AU_09_R",xlim = c(-.2,.2), ylim = c(-.2,.2))

```

### Plot individual median movement per participant using the function *plotIndmm*

Plots the individual median movement. These plots may be used for outlied detection of participants.

```{r, fig.show='hold'}
plotIndmm(data = data_Subj_happy, colNames = c("AU_09_L_x", "AU_09_L_y"), colNameSubj = "subject", title = "Posed Disgust",xlim = c(-.2,.2), ylim = c(-.2,.2))


```

----------------------------------------------------
----------------------------------------------------
----------------------------------------------------
----------------------------------------------------

*@Axel: fix me:* *Im Beispielvideo falsche Markerbennung (AU_08_R) korrigieren!*

----------------------------------------------------
----------------------------------------------------

@ Rainer: the rest is only to keep the examples :-)



The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
